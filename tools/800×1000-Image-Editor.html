<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>800×1000 Image Editor + Polaroid - Canva Code</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .bg-aurora {
      background: radial-gradient(1200px 600px at 10% 10%, #1f2937 0%, #0a0f1d 40%),
                  radial-gradient(800px 500px at 90% 20%, #0b3b5d55 0%, #0a0f1d 60%),
                  radial-gradient(900px 600px at 50% 100%, #2b7a7740 0%, #0a0f1d 60%);
    }
    canvas { image-rendering: -webkit-optimize-contrast; image-rendering: crisp-edges; } /* Fallback for compatibility */
    :focus-visible { outline: 2px solid #60a5fa; outline-offset: 2px; }
  </style>
</head>
<body class="min-h-screen bg-aurora text-slate-100 font-sans">
  <div class="max-w-7xl mx-auto px-4 py-8">
    <!-- Header (unchanged) -->
    <header class="flex flex-col md:flex-row md:items-end md:justify-between gap-4">
      <div>
        <h1 class="text-2xl md:text-3xl font-semibold tracking-tight">Canva Code — 800×1000 Image Editor</h1>
        <p class="text-slate-300 mt-1">Upload, adjust, and export a perfect 800×1000 image. Now with a polaroid overlay and LEASED banner.</p>
      </div>
      <div class="flex flex-wrap items-center gap-3">
        <label class="relative cursor-pointer inline-flex items-center">
          <input id="fileInput" type="file" accept="image/*" class="sr-only" />
          <span class="inline-flex items-center gap-2 bg-indigo-500 hover:bg-indigo-400 active:scale-[.99] transition text-white px-4 py-2 rounded-lg shadow">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" class="-ml-1">
              <path d="M4 17V7a3 3 0 0 1 3-3h5" stroke="white" stroke-width="1.5" stroke-linecap="round"/>
              <path d="M20 7v10a3 3 0 0 1-3 3H7" stroke="white" stroke-width="1.5" stroke-linecap="round"/>
              <path d="M14 3h7v7" stroke="white" stroke-width="1.5" stroke-linecap="round"/>
              <path d="M21 3l-8 8" stroke="white" stroke-width="1.5" stroke-linecap="round"/>
            </svg>
            <span>Upload background</span>
          </span>
        </label>
        <label class="relative cursor-pointer inline-flex items-center">
          <input id="fileInputPolaroid" type="file" accept="image/*" class="sr-only" />
          <span class="inline-flex items-center gap-2 bg-fuchsia-500 hover:bg-fuchsia-400 active:scale-[.99] transition text-white px-4 py-2 rounded-lg shadow">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" class="-ml-1">
              <path d="M4 12h16M12 4v16" stroke="white" stroke-width="1.5" stroke-linecap="round"/>
            </svg>
            <span>Upload polaroid</span>
          </span>
        </label>
        <button id="resetBtn" class="px-3 py-2 rounded-lg bg-slate-700 hover:bg-slate-600 text-slate-100 disabled:opacity-50" disabled>Reset</button>
        <button id="downloadBtn" class="px-4 py-2 rounded-lg bg-emerald-500 hover:bg-emerald-400 text-white shadow disabled:opacity-50" disabled>Download PNG</button>
      </div>
    </header>

    <!-- Main Layout (unchanged) -->
    <section class="mt-6 grid grid-cols-1 lg:grid-cols-3 gap-6">
      <div class="lg:col-span-2">
        <div class="rounded-2xl border border-white/10 bg-[#0d1324]/70 backdrop-blur p-4">
          <div class="flex items-center justify-between mb-3">
            <div class="flex items-center gap-2">
              <span class="text-sm text-slate-300">Preview</span>
              <span id="statusBadge" class="text-xs px-2 py-0.5 rounded bg-slate-700/70 text-slate-200">No image</span>
            </div>
            <div class="text-xs text-slate-400">Export size: 800 × 1000</div>
          </div>
          <div class="relative w-full">
            <div id="canvasHolder" class="relative mx-auto max-w-[900px]">
              <canvas id="previewCanvas" class="w-full rounded-xl bg-[conic-gradient(at_10%_10%,#0d1324,#0b1430)] border border-white/10 shadow-inner"
                aria-label="Image preview canvas" tabindex="0"></canvas>
              <div id="overlayGuides" class="pointer-events-none absolute inset-0 rounded-xl">
                <div class="absolute inset-0 rounded-xl ring-1 ring-white/15"></div>
                <div class="absolute inset-0 grid grid-cols-3 grid-rows-3">
                  <div class="border-r border-b border-white/10"></div>
                  <div class="border-r border-b border-white/10"></div>
                  <div class="border-b border-white/10"></div>
                  <div class="border-r border-b border-white/10"></div>
                  <div class="border-r border-b border-white/10"></div>
                  <div class="border-b border-white/10"></div>
                  <div class="border-r border-white/10"></div>
                  <div class="border-r border-white/10"></div>
                  <div></div>
                </div>
                <div class="absolute bottom-2 right-2 text-[11px] px-2 py-1 rounded bg-black/50 text-white">800 × 1000</div>
              </div>
            </div>
          </div>
          <p class="mt-3 text-xs text-slate-400">
            Tip: Choose which photo to adjust (background or polaroid). Drag to move, scroll to zoom, and use arrows to nudge.
          </p>
        </div>
      </div>
      <aside class="lg:col-span-1">
        <div class="rounded-2xl border border-white/10 bg-[#0d1324]/70 backdrop-blur p-4 space-y-6">
          <!-- Controls (unchanged) -->
          <div>
            <h3 class="text-sm font-medium mb-2">Adjust</h3>
            <div class="grid grid-cols-2 gap-2">
              <label class="flex items-center gap-2 p-2 rounded-lg bg-slate-800/60">
                <input type="radio" name="activeLayer" value="bg" id="activeBg" checked class="accent-indigo-400" />
                <span class="text-sm">Background</span>
              </label>
              <label class="flex items-center gap-2 p-2 rounded-lg bg-slate-800/60">
                <input type="radio" name="activeLayer" value="polaroid" id="activePolaroid" class="accent-fuchsia-400" />
                <span class="text-sm">Polaroid photo</span>
              </label>
            </div>
          </div>
          <div class="space-y-4">
            <div class="flex items-center justify-between">
              <h3 class="text-sm font-medium">Background fit</h3>
              <div id="fitLabel" class="text-xs text-slate-400">—</div>
            </div>
            <div class="grid grid-cols-2 gap-2">
              <button id="containBtn" class="px-3 py-2 rounded-lg bg-slate-700/70 hover:bg-slate-600 text-slate-100 disabled:opacity-60" disabled>Fit (contain)</button>
              <button id="coverBtn" class="px-3 py-2 rounded-lg bg-slate-700/70 hover:bg-slate-600 text-slate-100 disabled:opacity-60" disabled>Fill (cover)</button>
            </div>
            <div>
              <div class="flex items-center justify-between mb-2">
                <h3 class="text-sm font-medium">Zoom</h3>
                <span id="zoomValue" class="text-xs text-slate-400">1.00×</span>
              </div>
              <input id="zoomRange" type="range" min="0.2" max="5" step="0.01" value="1" class="w-full accent-indigo-400" disabled />
            </div>
            <div>
              <div class="flex items-center justify-between mb-2">
                <h3 class="text-sm font-medium">Rotate</h3>
                <span id="rotateValue" class="text-xs text-slate-400">0°</span>
              </div>
              <input id="rotateRange" type="range" min="-180" max="180" step="0.1" value="0" class="w-full accent-indigo-400" disabled />
            </div>
            <div>
              <div class="flex items-center justify-between mb-2">
                <h3 class="text-sm font-medium">Position</h3>
                <span id="posValue" class="text-xs text-slate-400">X: 0, Y: 0</span>
              </div>
              <div class="grid grid-cols-2 gap-2">
                <div class="flex items-center gap-2">
                  <span class="text-xs w-4 text-slate-400">X</span>
                  <input id="xRange" type="range" min="-800" max="800" step="1" value="0" class="w-full accent-indigo-400" disabled />
                </div>
                <div class="flex items-center gap-2">
                  <span class="text-xs w-4 text-slate-400">Y</span>
                  <input id="yRange" type="range" min="-1000" max="1000" step="1" value="0" class="w-full accent-indigo-400" disabled />
                </div>
              </div>
            </div>
            <div class="grid grid-cols-2 gap-2">
              <button id="flipHBtn" class="px-3 py-2 rounded-lg bg-slate-700/70 hover:bg-slate-600 text-slate-100 disabled:opacity-60" disabled>Flip H</button>
              <button id="flipVBtn" class="px-3 py-2 rounded-lg bg-slate-700/70 hover:bg-slate-600 text-slate-100 disabled:opacity-60" disabled>Flip V</button>
            </div>
            <div>
              <div class="flex items-center justify-between mb-2">
                <h3 class="text-sm font-medium">Background</h3>
                <span class="text-xs text-slate-400">Transparent by default</span>
              </div>
              <div class="flex items-center gap-3">
                <label class="flex items-center gap-2">
                  <input id="transparentToggle" type="checkbox" class="accent-indigo-400" checked />
                  <span class="text-sm">Transparent</span>
                </label>
                <label class="flex items-center gap-2">
                  <span class="text-sm text-slate-300">Color</span>
                  <input id="bgColor" type="color" value="#0d1324" class="w-10 h-8 rounded border border-white/10 bg-transparent" />
                </label>
              </div>
            </div>
            <div class="grid grid-cols-3 gap-2">
              <button id="centerBtn" class="px-3 py-2 rounded-lg bg-slate-700/70 hover:bg-slate-600 text-slate-100 disabled:opacity-60" disabled>Center</button>
              <button id="fitFrameBtn" class="px-3 py-2 rounded-lg bg-slate-700/70 hover:bg-slate-600 text-slate-100 disabled:opacity-60" disabled>Best fit</button>
              <button id="clearBtn" class="px-3 py-2 rounded-lg bg-rose-600/90 hover:bg-rose-500 text-white disabled:opacity-60" disabled>Clear</button>
            </div>
          </div>
          <div class="pt-2 border-t border-white/10 space-y-4">
            <div class="flex items-center justify-between">
              <h3 class="text-sm font-medium">Polaroid photo</h3>
              <span id="pStatus" class="text-xs text-slate-400">No photo</span>
            </div>
            <div>
              <div class="flex items-center justify-between mb-2">
                <span class="text-sm text-slate-300">Zoom</span>
                <span id="pZoomLabel" class="text-xs text-slate-400">1.00×</span>
              </div>
              <input id="pZoom" type="range" min="0.5" max="4" step="0.01" value="1" class="w-full accent-fuchsia-400" disabled />
            </div>
            <div>
              <div class="flex items-center justify-between mb-2">
                <span class="text-sm text-slate-300">Position</span>
                <span id="pPosLabel" class="text-xs text-slate-400">X: 0, Y: 0</span>
              </div>
              <div class="grid grid-cols-2 gap-2">
                <div class="flex items-center gap-2">
                  <span class="text-xs w-4 text-slate-400">X</span>
                  <input id="pX" type="range" min="-400" max="400" step="1" value="0" class="w-full accent-fuchsia-400" disabled />
                </div>
                <div class="flex items-center gap-2">
                  <span class="text-xs w-4 text-slate-400">Y</span>
                  <input id="pY" type="range" min="-400" max="400" step="1" value="0" class="w-full accent-fuchsia-400" disabled />
                </div>
              </div>
            </div>
            <div class="grid grid-cols-2 gap-2">
              <button id="pCenter" class="px-3 py-2 rounded-lg bg-slate-700/70 hover:bg-slate-600 text-slate-100 disabled:opacity-60" disabled>Center</button>
              <button id="pBestFit" class="px-3 py-2 rounded-lg bg-slate-700/70 hover:bg-slate-600 text-slate-100 disabled:opacity-60" disabled>Best fit</button>
            </div>
            <div class="grid grid-cols-1 gap-2">
              <div class="flex items-center gap-2">
                <label for="deskNumber" class="text-sm w-28 text-slate-300">Desk number</label>
                <input id="deskNumber" type="text" placeholder="e.g. D-24" class="flex-1 px-3 py-2 rounded-lg bg-slate-800/60 border border-white/10 text-slate-100 placeholder-slate-400" />
              </div>
              <div class="flex items-center gap-2">
                <label for="location" class="text-sm w-28 text-slate-300">Location</label>
                <input id="location" type="text" placeholder="e.g. Downtown, L2" class="flex-1 px-3 py-2 rounded-lg bg-slate-800/60 border border-white/10 text-slate-100 placeholder-slate-400" />
              </div>
              <div class="flex items-center gap-2">
                <label for="leasedBy" class="text-sm w-28 text-slate-300">Leased by</label>
                <input id="leasedBy" type="text" placeholder="e.g. Acme Corp" class="flex-1 px-3 py-2 rounded-lg bg-slate-800/60 border border-white/10 text-slate-100 placeholder-slate-400" />
              </div>
            </div>
          </div>
          <p class="text-xs text-slate-400">Everything exports as one image at exactly 800×1000, including the polaroid and text.</p>
        </div>
      </aside>
    </section>
  </div>
  <canvas id="exportCanvas" width="800" height="1000" class="hidden"></canvas>

  <script>
    // Elements (unchanged)
    const fileInput = document.getElementById('fileInput');
    const fileInputPolaroid = document.getElementById('fileInputPolaroid');
    const previewCanvas = document.getElementById('previewCanvas');
    const exportCanvas = document.getElementById('exportCanvas');
    const statusBadge = document.getElementById('statusBadge');
    const activeBg = document.getElementById('activeBg');
    const activePolaroid = document.getElementById('activePolaroid');
    const containBtn = document.getElementById('containBtn');
    const coverBtn = document.getElementById('coverBtn');
    const fitLabel = document.getElementById('fitLabel');
    const zoomRange = document.getElementById('zoomRange');
    const zoomValue = document.getElementById('zoomValue');
    const rotateRange = document.getElementById('rotateRange');
    const rotateValue = document.getElementById('rotateValue');
    const xRange = document.getElementById('xRange');
    const yRange = document.getElementById('yRange');
    const posValue = document.getElementById('posValue');
    const flipHBtn = document.getElementById('flipHBtn');
    const flipVBtn = document.getElementById('flipVBtn');
    const transparentToggle = document.getElementById('transparentToggle');
    const bgColor = document.getElementById('bgColor');
    const centerBtn = document.getElementById('centerBtn');
    const fitFrameBtn = document.getElementById('fitFrameBtn');
    const clearBtn = document.getElementById('clearBtn');
    const pStatus = document.getElementById('pStatus');
    const pZoom = document.getElementById('pZoom');
    const pZoomLabel = document.getElementById('pZoomLabel');
    const pX = document.getElementById('pX');
    const pY = document.getElementById('pY');
    const pPosLabel = document.getElementById('pPosLabel');
    const pCenter = document.getElementById('pCenter');
    const pBestFit = document.getElementById('pBestFit');
    const deskNumber = document.getElementById('deskNumber');
    const locationInput = document.getElementById('location');
    const leasedBy = document.getElementById('leasedBy');
    const resetBtn = document.getElementById('resetBtn');
    const downloadBtn = document.getElementById('downloadBtn');

    // State (unchanged)
    const EXPORT_W = 800;
    const EXPORT_H = 1000;
    let img = new Image();
    let imgLoaded = false;
    let mode = 'cover';
    let baseScale = 1;
    let userZoom = 1;
    let rotation = 0;
    let offsetX = 0;
    let offsetY = 0;
    let flipH = false;
    let flipV = false;
    let transparent = true;
    let bg = '#0d1324';
    let pImg = new Image();
    let pLoaded = false;
    let pBaseScale = 1;
    let pUserZoom = 1;
    let pOffsetX = 0;
    let pOffsetY = 0;
    let activeLayer = 'bg';
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };
    let startOffset = { x: 0, y: 0 };
    let constrainAxis = null;

    // Initialize canvas contexts
    const pctx = previewCanvas.getContext('2d', { alpha: true });
    const ectx = exportCanvas.getContext('2d', { alpha: true });

    // Debounce utility for performance
    function debounce(func, wait) {
      let timeout;
      return function (...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
      };
    }

    function enableControls(enable) {
      [containBtn, coverBtn, zoomRange, rotateRange, xRange, yRange,
       flipHBtn, flipVBtn, centerBtn, fitFrameBtn, clearBtn,
       resetBtn, downloadBtn].forEach(el => el.disabled = !enable);
    }

    function enablePolaroidControls(enable) {
      [pZoom, pX, pY, pCenter, pBestFit].forEach(el => el.disabled = !enable);
    }

    function updateLabels() {
      fitLabel.textContent = mode === 'cover' ? 'Fill' : 'Fit';
      zoomValue.textContent = userZoom.toFixed(2) + '×';
      rotateValue.textContent = Math.round(rotation) + '°';
      posValue.textContent = `X: ${Math.round(offsetX)}, Y: ${Math.round(offsetY)}`;
      pZoomLabel.textContent = pUserZoom.toFixed(2) + '×';
      pPosLabel.textContent = `X: ${Math.round(pOffsetX)}, Y: ${Math.round(pOffsetY)}`;
      const ready = imgLoaded || pLoaded;
      statusBadge.textContent = ready ? 'Ready' : 'No image';
      statusBadge.className = 'text-xs px-2 py-0.5 rounded ' + (ready ? 'bg-emerald-600/80' : 'bg-slate-700/70');
      pStatus.textContent = pLoaded ? 'Ready' : 'No photo';
      downloadBtn.disabled = !ready;
    }

    function computeBaseScale() {
      if (!imgLoaded) return;
      const sx = EXPORT_W / img.width;
      const sy = EXPORT_H / img.height;
      baseScale = (mode === 'cover') ? Math.max(sx, sy) : Math.min(sx, sy);
    }

    // Adjusted polaroid scaling to maintain aspect ratio
    function computePolaroidBaseScale() {
      if (!pLoaded) return;
      const sx = imgAreaSize / pImg.width;
      const sy = imgAreaSize / pImg.height;
      pBaseScale = Math.min(sx, sy); // Changed to contain to avoid distortion
    }

    function roundedRectPath(ctx, x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.arcTo(x + w, y, x + w, y + h, r);
      ctx.arcTo(x + w, y + h, x, y + h, r);
      ctx.arcTo(x, y + h, x, y, r);
      ctx.arcTo(x, y, x + w, y, r);
      ctx.closePath();
    }

    function sizePreviewCanvas() {
      const holder = document.getElementById('canvasHolder');
      const maxW = holder.clientWidth;
      const targetW = maxW;
      const targetH = Math.round(targetW * (5/4));
      const dpr = Math.min(window.devicePixelRatio || 1, 2);
      previewCanvas.width = Math.floor(targetW * dpr);
      previewCanvas.height = Math.floor(targetH * dpr);
      previewCanvas.style.width = targetW + 'px';
      previewCanvas.style.height = targetH + 'px';
      pctx.imageSmoothingEnabled = true; // Ensure quality rendering
    }

    function drawBackground(ctx, outW, outH) {
      if (!transparent) {
        ctx.fillStyle = bg;
        ctx.fillRect(0, 0, outW, outH);
      } else {
        ctx.clearRect(0, 0, outW, outH);
      }

      if (!imgLoaded) return;

      ctx.save();
      ctx.translate(outW / 2 + offsetX * (outW / EXPORT_W), outH / 2 + offsetY * (outH / EXPORT_H));
      ctx.rotate(rotation * Math.PI / 180);
      const scale = baseScale * userZoom;
      const signX = flipH ? -1 : 1;
      const signY = flipV ? -1 : 1;
      const unit = outW / EXPORT_W;
      ctx.scale(scale * unit * signX, scale * unit * signY);
      try {
        ctx.drawImage(img, -img.width / 2, -img.height / 2);
      } catch (err) {
        console.error('Error drawing background image:', err);
      }
      ctx.restore();
    }

    // Polaroid layout constants (unchanged)
    const cardW = 560;
    const cardH = 680;
    const cardR = 28;
    const cardX = (EXPORT_W - cardW) / 2;
    const cardY = 260;
    const bannerH = 72;
    const imgMargin = 40;
    const imgAreaY = cardY + bannerH + imgMargin;
    const imgAreaX = cardX + imgMargin;
    const imgAreaSize = cardW - imgMargin * 2;
    const textAreaH = 110;

    function drawPolaroid(ctx, outW, outH) {
      const unit = outW / EXPORT_W;
      const x = cardX * unit;
      const y = cardY * unit;
      const w = cardW * unit;
      const h = cardH * unit;
      const r = cardR * unit;

      ctx.save();
      ctx.shadowColor = 'rgba(0,0,0,0.35)';
      ctx.shadowBlur = 24 * unit;
      ctx.shadowOffsetY = 10 * unit;
      ctx.fillStyle = '#ffffff';
      roundedRectPath(ctx, x, y, w, h, r);
      ctx.fill();
      ctx.restore();

      ctx.save();
      ctx.fillStyle = '#ef4444';
      roundedRectPath(ctx, x, y, w, bannerH * unit, r);
      ctx.fill();
      ctx.fillStyle = '#ffffff';
      ctx.font = `${Math.round(36 * unit)}px ui-sans-serif, system-ui, -apple-system`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('LEASED', x + w / 2, y + (bannerH * unit) / 2);
      ctx.restore();

      const iaX = imgAreaX * unit;
      const iaY = imgAreaY * unit;
      const iaS = imgAreaSize * unit;
      ctx.save();
      roundedRectPath(ctx, iaX, iaY, iaS, iaS, 20 * unit);
      ctx.clip();
      ctx.fillStyle = '#e5e7eb';
      ctx.fillRect(iaX, iaY, iaS, iaS);

      if (pLoaded) {
        ctx.save();
        const px = iaX + iaS / 2 + pOffsetX * unit;
        const py = iaY + iaS / 2 + pOffsetY * unit;
        ctx.translate(px, py);
        const scale = pBaseScale * pUserZoom * unit;
        ctx.scale(scale, scale);
        try {
          ctx.drawImage(pImg, -pImg.width / 2, -pImg.height / 2);
        } catch (err) {
          console.error('Error drawing polaroid image:', err);
        }
        ctx.restore();
      }
      ctx.restore();

      ctx.save();
      ctx.fillStyle = '#0f172a';
      const txtPad = 18 * unit;
      const tx = (cardX + txtPad) * unit;
      const tw = (cardW - txtPad * 2) * unit;
      const ty = (cardY + cardH - textAreaH + 18) * unit;
      ctx.font = `${Math.round(18 * unit)}px ui-sans-serif, system-ui, -apple-system`;
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      const line1 = deskNumber.value ? `Desk: ${deskNumber.value}` : '';
      const line2 = locationInput.value ? `Location: ${locationInput.value}` : '';
      const line3 = leasedBy.value ? `Leased by: ${leasedBy.value}` : '';
      const lines = [line1, line2, line3].filter(Boolean);
      let yCursor = ty;
      lines.forEach((t) => { ctx.fillText(t, tx, yCursor); yCursor += 26 * unit; });
      ctx.restore();
    }

    const drawAll = debounce(() => {
      try {
        ectx.clearRect(0, 0, EXPORT_W, EXPORT_H);
        drawBackground(ectx, EXPORT_W, EXPORT_H);
        drawPolaroid(ectx, EXPORT_W, EXPORT_H);
        pctx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
        drawBackground(pctx, previewCanvas.width, previewCanvas.height);
        drawPolaroid(pctx, previewCanvas.width, previewCanvas.height);
        updateLabels();
      } catch (err) {
        console.error('Error in drawAll:', err);
      }
    }, 16); // ~60fps

    function syncControlsFromState() {
      zoomRange.value = userZoom.toFixed(2);
      rotateRange.value = rotation;
      xRange.value = offsetX;
      yRange.value = offsetY;
      pZoom.value = pUserZoom.toFixed(2);
      pX.value = pOffsetX;
      pY.value = pOffsetY;
    }

    function sizeAndRedraw() {
      sizePreviewCanvas();
      drawAll();
    }

    // File handling (background)
    fileInput.addEventListener('change', (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      const url = URL.createObjectURL(file);
      const tmp = new Image();
      tmp.crossOrigin = 'Anonymous'; // Handle potential CORS
      tmp.onload = () => {
        img = tmp;
        imgLoaded = true;
        mode = 'cover';
        userZoom = 1;
        rotation = 0;
        flipH = false;
        flipV = false;
        offsetX = 0;
        offsetY = 0;
        computeBaseScale();
        sizePreviewCanvas();
        enableControls(true);
        syncControlsFromState();
        drawAll();
        URL.revokeObjectURL(url);
      };
      tmp.onerror = () => {
        alert('Sorry, that image failed to load. Please try another image.');
        URL.revokeObjectURL(url);
      };
      tmp.src = url;
    });

    // File handling (polaroid)
    fileInputPolaroid.addEventListener('change', (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      const url = URL.createObjectURL(file);
      const tmp = new Image();
      tmp.crossOrigin = 'Anonymous';
      tmp.onload = () => {
        pImg = tmp;
        pLoaded = true;
        pUserZoom = 1;
        pOffsetX = 0;
        pOffsetY = 0;
        computePolaroidBaseScale();
        enablePolaroidControls(true);
        syncControlsFromState();
        drawAll();
        URL.revokeObjectURL(url);
      };
      tmp.onerror = () => {
        alert('Sorry, that polaroid photo failed to load. Please try another image.');
        URL.revokeObjectURL(url);
      };
      tmp.src = url;
    });

    // Active layer selection
    activeBg.addEventListener('change', () => { if (activeBg.checked) activeLayer = 'bg'; });
    activePolaroid.addEventListener('change', () => { if (activePolaroid.checked) activeLayer = 'polaroid'; });

    // Background control events
    containBtn.addEventListener('click', () => { mode = 'contain'; computeBaseScale(); drawAll(); });
    coverBtn.addEventListener('click', () => { mode = 'cover'; computeBaseScale(); drawAll(); });
    zoomRange.addEventListener('input', () => { userZoom = parseFloat(zoomRange.value); drawAll(); });
    rotateRange.addEventListener('input', () => { rotation = parseFloat(rotateRange.value); drawAll(); });
    xRange.addEventListener('input', () => { offsetX = parseInt(xRange.value, 10); drawAll(); });
    yRange.addEventListener('input', () => { offsetY = parseInt(yRange.value, 10); drawAll(); });
    flipHBtn.addEventListener('click', () => { flipH = !flipH; drawAll(); });
    flipVBtn.addEventListener('click', () => { flipV = !flipV; drawAll(); });
    transparentToggle.addEventListener('change', () => { transparent = transparentToggle.checked; drawAll(); });
    bgColor.addEventListener('input', () => { bg = bgColor.value; transparent = false; transparentToggle.checked = false; drawAll(); });
    centerBtn.addEventListener('click', () => { offsetX = 0; offsetY = 0; syncControlsFromState(); drawAll(); });
    fitFrameBtn.addEventListener('click', () => {
      userZoom = 1;
      rotation = 0;
      flipH = false;
      flipV = false;
      offsetX = 0;
      offsetY = 0;
      computeBaseScale();
      syncControlsFromState();
      drawAll();
    });
    clearBtn.addEventListener('click', () => {
      imgLoaded = false;
      mode = 'cover';
      baseScale = 1;
      userZoom = 1;
      rotation = 0;
      offsetX = 0;
      offsetY = 0;
      flipH = false;
      flipV = false;
      transparent = true;
      transparentToggle.checked = true;
      bg = '#0d1324';
      bgColor.value = bg;
      enableControls(false);
      drawAll();
    });

    // Polaroid control events
    pZoom.addEventListener('input', () => { pUserZoom = parseFloat(pZoom.value); drawAll(); });
    pX.addEventListener('input', () => { pOffsetX = parseInt(pX.value, 10); drawAll(); });
    pY.addEventListener('input', () => { pOffsetY = parseInt(pY.value, 10); drawAll(); });
    pCenter.addEventListener('click', () => { pOffsetX = 0; pOffsetY = 0; syncControlsFromState(); drawAll(); });
    pBestFit.addEventListener('click', () => { pUserZoom = 1; computePolaroidBaseScale(); syncControlsFromState(); drawAll(); });

    // Lease info live update
    [deskNumber, locationInput, leasedBy].forEach(inp => inp.addEventListener('input', drawAll));

    // Download (consolidated)
    downloadBtn.addEventListener('click', () => {
      try {
        const link = document.createElement('a');
        link.download = 'image-800x1000.png';
        link.href = exportCanvas.toDataURL('image/png');
        link.click();
      } catch (err) {
        alert('Error exporting image. Please try again.');
        console.error('Download error:', err);
      }
    });

    // Reset
    resetBtn.addEventListener('click', () => {
      if (imgLoaded) {
        mode = 'cover';
        userZoom = 1;
        rotation = 0;
        flipH = false;
        flipV = false;
        offsetX = 0;
        offsetY = 0;
        computeBaseScale();
      }
      if (pLoaded) {
        pUserZoom = 1;
        pOffsetX = 0;
        pOffsetY = 0;
        computePolaroidBaseScale();
      }
      deskNumber.value = '';
      locationInput.value = '';
      leasedBy.value = '';
      transparent = true;
      transparentToggle.checked = true;
      bg = '#0d1324';
      bgColor.value = bg;
      syncControlsFromState();
      drawAll();
    });

    // Interactions
    function previewToExportDelta(dx, dy) {
      const sx = previewCanvas.width / EXPORT_W;
      const sy = previewCanvas.height / EXPORT_H;
      return { dx: dx / sx, dy: dy / sy };
    }

    previewCanvas.addEventListener('pointerdown', (e) => {
      if (!(imgLoaded || pLoaded)) return;
      previewCanvas.setPointerCapture(e.pointerId);
      isDragging = true;
      dragStart = { x: e.clientX, y: e.clientY };
      if (activeLayer === 'bg') startOffset = { x: offsetX, y: offsetY };
      if (activeLayer === 'polaroid') startOffset = { x: pOffsetX, y: pOffsetY };
      constrainAxis = e.shiftKey ? 'pending' : null;
    });

    previewCanvas.addEventListener('pointermove', (e) => {
      if (!isDragging) return;
      const dx = e.clientX - dragStart.x;
      const dy = e.clientY - dragStart.y;

      if (constrainAxis === 'pending') {
        if (Math.abs(dx) > 3 || Math.abs(dy) > 3) {
          constrainAxis = Math.abs(dx) > Math.abs(dy) ? 'x' : 'y';
        } else { return; }
      }

      let moveX = dx, moveY = dy;
      if (constrainAxis === 'x') moveY = 0;
      if (constrainAxis === 'y') moveX = 0;

      const delta = previewToExportDelta(moveX, moveY);
      if (activeLayer === 'bg') {
        offsetX = Math.round(startOffset.x + delta.dx);
        offsetY = Math.round(startOffset.y + delta.dy);
        xRange.value = offsetX;
        yRange.value = offsetY;
      } else {
        pOffsetX = Math.round(startOffset.x + delta.dx);
        pOffsetY = Math.round(startOffset.y + delta.dy);
        pX.value = pOffsetX;
        pY.value = pOffsetY;
      }
      drawAll();
    });

    const endDrag = (e) => {
      if (!isDragging) return;
      isDragging = false;
      constrainAxis = null;
      try { previewCanvas.releasePointerCapture(e.pointerId); } catch {}
    };
    previewCanvas.addEventListener('pointerup', endDrag);
    previewCanvas.addEventListener('pointercancel', endDrag);
    previewCanvas.addEventListener('pointerleave', endDrag);

    previewCanvas.addEventListener('wheel', (e) => {
      if (!(imgLoaded || pLoaded)) return;
      e.preventDefault();
      const delta = -Math.sign(e.deltaY) * 0.05;
      if (activeLayer === 'bg') {
        userZoom = Math.min(5, Math.max(0.2, userZoom + delta));
        zoomRange.value = userZoom.toFixed(2);
      } else {
        pUserZoom = Math.min(4, Math.max(0.5, pUserZoom + delta));
        pZoom.value = pUserZoom.toFixed(2);
      }
      drawAll();
    }, { passive: false });

    previewCanvas.addEventListener('keydown', (e) => {
      if (!(imgLoaded || pLoaded)) return;
      let step = e.shiftKey ? 10 : 2;
      if (activeLayer === 'bg') {
        if (e.key === 'ArrowLeft') { offsetX -= step; e.preventDefault(); }
        if (e.key === 'ArrowRight') { offsetX += step; e.preventDefault(); }
        if (e.key === 'ArrowUp') { offsetY -= step; e.preventDefault(); }
        if (e.key === 'ArrowDown') { offsetY += step; e.preventDefault(); }
        if (['ArrowLeft','ArrowRight','ArrowUp','ArrowDown'].includes(e.key)) {
          xRange.value = offsetX;
          yRange.value = offsetY;
          drawAll();
        }
        if (e.key.toLowerCase() === 'r') { rotation = 0; rotateRange.value = rotation; drawAll(); }
        if (e.key.toLowerCase() === 'f') { mode = (mode === 'cover' ? 'contain' : 'cover'); computeBaseScale(); drawAll(); }
        if (e.key === '+') { userZoom = Math.min(5, +(userZoom + 0.05).toFixed(2)); zoomRange.value = userZoom; drawAll(); }
        if (e.key === '-') { userZoom = Math.max(0.2, +(userZoom - 0.05).toFixed(2)); zoomRange.value = userZoom; drawAll(); }
      } else {
        if (e.key === 'ArrowLeft') { pOffsetX -= step; e.preventDefault(); }
        if (e.key === 'ArrowRight') { pOffsetX += step; e.preventDefault(); }
        if (e.key === 'ArrowUp') { pOffsetY -= step; e.preventDefault(); }
        if (e.key === 'ArrowDown') { pOffsetY += step; e.preventDefault(); }
        if (['ArrowLeft','ArrowRight','ArrowUp','ArrowDown'].includes(e.key)) {
          pX.value = pOffsetX;
          pY.value = pOffsetY;
          drawAll();
        }
        if (e.key === '+') { pUserZoom = Math.min(4, +(pUserZoom + 0.05).toFixed(2)); pZoom.value = pUserZoom; drawAll(); }
        if (e.key === '-') { pUserZoom = Math.max(0.5, +(pUserZoom - 0.05).toFixed(2)); pZoom.value = pZoom; drawAll(); }
      }
      if (e.key === 'Enter') { downloadBtn.click(); }
    });

    // Resize handling with cleanup
    const resizeObserver = new ResizeObserver(sizeAndRedraw);
    resizeObserver.observe(document.getElementById('canvasHolder'));
    window.addEventListener('orientationchange', sizeAndRedraw);
    window.addEventListener('unload', () => {
      resizeObserver.disconnect();
      window.removeEventListener('orientationchange', sizeAndRedraw);
    });

    // Initial setup
    sizePreviewCanvas();
    enableControls(false);
    enablePolaroidControls(false);
    updateLabels();
  </script>
</body>
</html>
