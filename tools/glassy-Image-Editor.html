<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Canva Code ‚Ä¢ Vertical Image Editor (Glassy Circle + Live XYR)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Font -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;600;800&display=swap" rel="stylesheet">
  <style>
    body{ font-family:'Inter',system-ui,Segoe UI,Roboto,Arial,sans-serif; background: radial-gradient(1100px 700px at 20% -10%, #1f2a44 0%, #0a0f1d 50%, #070a13 100%); }
    .glass{ background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03)); border:1px solid rgba(255,255,255,.08); backdrop-filter: blur(6px); }
    .canvas-wrap{ aspect-ratio: 9/16; position: relative; }
    input[type="file"]{ display:none; }
    .badge{ pointer-events:none; }
  </style>
</head>
<body class="text-slate-100 min-h-screen">
  <!-- Header -->
  <header class="w-full max-w-6xl mx-auto px-4 sm:px-6 py-5 flex items-center justify-between">
    <div class="flex items-center gap-3">
      <div class="w-10 h-10 rounded-xl bg-violet-600/90 grid place-items-center shadow-lg shadow-violet-900/50">
        <span class="font-extrabold text-white">CC</span>
      </div>
      <div>
        <h1 class="text-xl sm:text-2xl font-extrabold tracking-tight">Canva Code ‚Ä¢ Vertical Image Editor</h1>
        <p class="text-slate-300 text-xs sm:text-sm">Upload ‚Ä¢ glassy blurred circle ‚Ä¢ live X/Y/R ‚Ä¢ subtitle + title inside</p>
      </div>
    </div>
    <div class="flex items-center gap-2">
      <button id="downloadBtn" class="px-4 py-2 rounded-lg bg-emerald-500 hover:bg-emerald-400 text-slate-900 font-semibold shadow-lg transition">Download</button>
    </div>
  </header>

  <!-- Main -->
  <main class="w-full max-w-6xl mx-auto px-4 sm:px-6 pb-10">
    <div class="grid grid-cols-1 lg:grid-cols-[360px_minmax(0,1fr)] gap-6">
      <!-- Controls -->
      <section class="glass rounded-2xl p-5 space-y-6">
        <div class="space-y-3">
          <h2 class="font-semibold text-lg">Start</h2>
          <label class="block">
            <input id="fileInput" type="file" accept="image/*" />
            <div class="w-full cursor-pointer rounded-xl border border-white/10 bg-white/5 hover:bg-white/10 transition p-4 flex items-center justify-between">
              <div class="flex items-center gap-3">
                <div class="w-9 h-9 rounded-lg bg-violet-600/80 grid place-items-center">üì§</div>
                <div>
                  <p class="font-semibold">Upload image</p>
                  <p class="text-xs text-slate-300">PNG ‚Ä¢ JPG ‚Ä¢ WEBP</p>
                </div>
              </div>
              <span class="text-sm px-3 py-1 rounded-lg bg-white/10">Choose</span>
            </div>
          </label>
          <div class="grid grid-cols-3 gap-2 pt-3">
            <div class="space-y-1">
              <label class="text-xs text-slate-400" for="imgX">Image X</label>
              <input id="imgX" type="number" value="0" class="w-full rounded-lg bg-white/5 border border-white/10 px-2 py-2 outline-none">
            </div>
            <div class="space-y-1">
              <label class="text-xs text-slate-400" for="imgY">Image Y</label>
              <input id="imgY" type="number" value="0" class="w-full rounded-lg bg-white/5 border border-white/10 px-2 py-2 outline-none">
            </div>
            <div class="space-y-1">
              <label class="text-xs text-slate-400" for="imgScale">Image Scale</label>
              <input id="imgScale" type="number" step="0.01" value="1" class="w-full rounded-lg bg-white/5 border border-white/10 px-2 py-2 outline-none">
            </div>
          </div>
        </div>

        <div class="h-px bg-white/10"></div>

        <div class="space-y-3">
          <h2 class="font-semibold text-lg">Text inside circle</h2>
          <input id="subtitleInput" type="text" placeholder="Subtitle (thin)" class="w-full rounded-lg bg-white/5 border border-white/10 px-3 py-2 outline-none focus:ring-2 focus:ring-violet-500/50" />
          <input id="titleInput" type="text" placeholder="Title (bold)" class="w-full rounded-lg bg-white/5 border border-white/10 px-3 py-2 outline-none focus:ring-2 focus:ring-violet-500/50" />
          <div class="grid grid-cols-3 gap-2">
            <div class="space-y-1">
              <label class="text-xs text-slate-400" for="textOffsetX">Text offset X</label>
              <input id="textOffsetX" type="number" value="0" class="w-full rounded-lg bg-white/5 border border-white/10 px-2 py-2 outline-none">
            </div>
            <div class="space-y-1">
              <label class="text-xs text-slate-400" for="textOffsetY">Text offset Y</label>
              <input id="textOffsetY" type="number" value="-24" class="w-full rounded-lg bg-white/5 border border-white/10 px-2 py-2 outline-none">
            </div>
            <div class="space-y-1">
              <label class="text-xs text-slate-400" for="textColor">Color</label>
              <input id="textColor" type="color" value="#ffffff" class="w-full h-[42px] rounded-lg border border-white/10 bg-transparent">
            </div>
          </div>
          <p class="text-xs text-slate-400">Fixed sizes: subtitle 54 (thin), title 80 (bold). Left‚Äëaligned, block centered vertically (nudged up). Defaults: Text X 100, Y -150.</p>
        </div>

        <div class="h-px bg-white/10"></div>

        <div class="space-y-3">
          <h2 class="font-semibold text-lg">Circle</h2>
          <div class="grid grid-cols-3 gap-2">
            <div class="space-y-1">
              <label class="text-xs text-slate-400" for="circleX">X</label>
              <input id="circleX" type="number" value="480" class="w-full rounded-lg bg-white/5 border border-white/10 px-2 py-2 outline-none">
            </div>
            <div class="space-y-1">
              <label class="text-xs text-slate-400" for="circleY">Y</label>
              <input id="circleY" type="number" value="1600" class="w-full rounded-lg bg-white/5 border border-white/10 px-2 py-2 outline-none">
            </div>
            <div class="space-y-1">
              <label class="text-xs text-slate-400" for="circleR">R</label>
              <input id="circleR" type="number" value="525" class="w-full rounded-lg bg-white/5 border border-white/10 px-2 py-2 outline-none">
            </div>
          </div>
          <div class="flex items-center justify-between gap-2">
            <label for="circleSize" class="text-sm text-slate-300">Radius (R)</label>
            <input id="circleSize" type="range" min="160" max="560" value="525" class="w-40">
          </div>
          <p class="text-xs text-slate-400">Drag the circle to move it. Live badge shows X/Y/R while dragging.</p>
        </div>
      </section>

      <!-- Canvas -->
      <section class="glass rounded-2xl p-4">
        <div class="flex items-center justify-between px-1 py-1">
          <div class="text-sm text-slate-300">Canvas 1080√ó1920</div>
          <div class="text-xs text-slate-400">Vertical ‚Ä¢ Glassy circle</div>
        </div>
        <div class="canvas-wrap w-full rounded-xl overflow-hidden bg-[#0d1222] grid place-items-center">
          <canvas id="canvas" width="1080" height="1920" class="w-full h-auto"></canvas>
          <div id="coordsBadge" class="badge absolute text-[11px] leading-none px-2 py-1 rounded-md bg-black/70 border border-white/10 shadow-md hidden">X: 0 ‚Ä¢ Y: 0 ‚Ä¢ R: 0</div>
          <div id="emptyState" class="absolute text-center text-slate-300 opacity-80 px-6">
            <div class="text-5xl mb-3">üñºÔ∏è</div>
            <p class="text-lg font-semibold">Upload an image to begin</p>
            <p class="text-sm">Your photo fills the background. Drag the glassy blurred circle anywhere; text stays inside.</p>
          </div>
        </div>
      </section>
    </div>
  </main>

  <script>
    // State
    const state = {
      img: null,
      imgW: 0, imgH: 0,
      cover: { dx:0, dy:0, dw:0, dh:0 },
      imageAdjust: { x: 0, y: 0, scale: 1 },
      circle: { mode:'free', cx: 480, cy: 1600, radius: 525 },
      text: {
        subtitle:'', title:'',
        color:'#ffffff',
        // Requested sizes
        subtitleSize:54,
        titleSize:80,
        // Nudge block position relative to circle center
        offsetX: 100,
        offsetY: -150
      }
    };

    // Elements
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const fileInput = document.getElementById('fileInput');

    const subtitleInput = document.getElementById('subtitleInput');
    const titleInput = document.getElementById('titleInput');
    const textColor = document.getElementById('textColor');
    const textOffsetX = document.getElementById('textOffsetX');
    const textOffsetY = document.getElementById('textOffsetY');

    const circleX = document.getElementById('circleX');
    const circleY = document.getElementById('circleY');
    const circleR = document.getElementById('circleR');
    const circleSize = document.getElementById('circleSize');

    const coordsBadge = document.getElementById('coordsBadge');
    const emptyState = document.getElementById('emptyState');
    const downloadBtn = document.getElementById('downloadBtn');

    const imgX = document.getElementById('imgX');
    const imgY = document.getElementById('imgY');
    const imgScale = document.getElementById('imgScale');

    // Helpers
    function computeCover() {
      if (!state.img) return;
      const cw = canvas.width, ch = canvas.height;
      const s = Math.max(cw / state.imgW, ch / state.imgH);
      const dw = state.imgW * s, dh = state.imgH * s;
      const dx = (cw - dw) / 2, dy = (ch - dh) / 2;
      state.cover = { dx, dy, dw, dh };
    }

    function circleCenter() {
      return { x: state.circle.cx, y: state.circle.cy };
    }

    function drawBackground() {
      const { dx, dy, dw, dh } = state.cover;
      const { x: ox, y: oy, scale } = state.imageAdjust;
      const cx = dx + ox; const cy = dy + oy;
      const sw = dw * scale; const sh = dh * scale;
      ctx.drawImage(state.img, cx + (dw - sw)/2, cy + (dh - sh)/2, sw, sh);
    }

    // Glassy circle: single layer, stronger blur (8px), soft depth
    function drawGlassyCircle() {
      const { x, y } = circleCenter();
      const r = state.circle.radius;

      ctx.save();
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.clip();

      // background sample (aligned), stronger blur
      const { dx, dy, dw, dh } = state.cover;
      ctx.filter = 'blur(8px)';
      ctx.drawImage(state.img, dx, dy, dw, dh);
      ctx.filter = 'none';

      // subtle inner depth
      const depth = ctx.createRadialGradient(x, y, r * 0.45, x, y, r);
      depth.addColorStop(0, 'rgba(0,0,0,0)');
      depth.addColorStop(1, 'rgba(0,0,0,0.22)');
      ctx.fillStyle = depth;
      ctx.fillRect(x - r, y - r, r * 2, r * 2);

      // gentle frost
      ctx.fillStyle = 'rgba(255,255,255,0.06)';
      ctx.fillRect(x - r, y - r, r * 2, r * 2);

      // soft gloss (top-left)
      const hl = ctx.createRadialGradient(x - r * 0.35, y - r * 0.35, 0, x - r * 0.35, y - r * 0.35, r * 0.9);
      hl.addColorStop(0, 'rgba(255,255,255,0.16)');
      hl.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = hl;
      ctx.fillRect(x - r, y - r, r * 2, r * 2);

      // soft text shadow
      ctx.shadowColor = 'rgba(0,0,0,0.35)';
      ctx.shadowBlur = 16;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 8;

      ctx.restore();
    }

    // Text block centered vertically, left-aligned, inside circle with offsets
    function drawTextInCircle() {
      const { subtitle, title, color, subtitleSize, titleSize, offsetX, offsetY } = state.text;
      if (!subtitle && !title) return;

      const { x, y } = circleCenter();
      const r = state.circle.radius;

      const padding = 28;
      const leftX = (x - r + padding) + offsetX;
      const maxW = (r * 2) - padding * 2;

      ctx.save();
      ctx.fillStyle = color;
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';

      // measure total height to center vertically, then nudge with offsetY
      ctx.font = `300 ${subtitleSize}px Inter`;
      const subLines = subtitle ? wrapLines(ctx, subtitle, maxW) : [];
      const subH = subLines.length * (subtitleSize * 1.28);

      const gap = (subtitle && title) ? 10 : 0;

      ctx.font = `800 ${titleSize}px Inter`;
      const titleLines = title ? wrapLines(ctx, title, maxW) : [];
      const titleH = titleLines.length * (titleSize * 1.12);

      const totalH = subH + gap + titleH;

      // Clip to circle
      ctx.beginPath();
      ctx.arc(x, y, r - 8, 0, Math.PI * 2);
      ctx.clip();

      // start Y centered, then apply offsetY (negative lifts up)
      let cy = y - totalH / 2 + offsetY;

      if (subLines.length) {
        ctx.font = `300 ${subtitleSize}px Inter`;
        for (const line of subLines) {
          ctx.fillText(line, leftX, cy);
          cy += subtitleSize * 1.28;
        }
        cy += gap;
      }

      if (titleLines.length) {
        ctx.font = `800 ${titleSize}px Inter`;
        for (const line of titleLines) {
          ctx.fillText(line, leftX, cy);
          cy += titleSize * 1.12;
        }
      }

      // soft text shadow
      ctx.shadowColor = 'rgba(0,0,0,0.35)';
      ctx.shadowBlur = 16;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 8;

      ctx.restore();
    }

    function wrapLines(context, text, maxWidth) {
      const words = (text || '').split(/\s+/);
      const lines = [];
      let line = '';
      for (let i = 0; i < words.length; i++) {
        const test = line ? line + ' ' + words[i] : words[i];
        if (context.measureText(test).width > maxWidth && line) {
          lines.push(line);
          line = words[i];
        } else {
          line = test;
        }
      }
      if (line) lines.push(line);
      return lines;
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (!state.img) return;
      drawBackground();
      drawGlassyCircle();
      drawTextInCircle();
    }

    // Events
    fileInput.addEventListener('change', (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        const img = new Image();
        img.onload = () => {
          state.img = img;
          state.imgW = img.naturalWidth;
          state.imgH = img.naturalHeight;
          computeCover();
          emptyState.style.display = 'none';
          // sync UI to defaults
          circleX.value = state.circle.cx;
          circleY.value = state.circle.cy;
          circleR.value = state.circle.radius;
          circleSize.value = state.circle.radius;
          textOffsetX.value = state.text.offsetX;
          textOffsetY.value = state.text.offsetY;
          imgX.value = state.imageAdjust.x;
          imgY.value = state.imageAdjust.y;
          imgScale.value = state.imageAdjust.scale;
          draw();
        };
        img.src = reader.result;
      };
      reader.readAsDataURL(file);
    });

    window.addEventListener('resize', () => {
      if (state.img) { computeCover(); draw(); }
    });

    // Image controls
    ;[imgX, imgY, imgScale].forEach(inp => {
      inp.addEventListener('input', () => {
        state.imageAdjust.x = parseFloat(imgX.value || 0);
        state.imageAdjust.y = parseFloat(imgY.value || 0);
        let s = parseFloat(imgScale.value || 1);
        if (!isFinite(s) || s <= 0) s = 1;
        state.imageAdjust.scale = s;
        draw();
      });
    });

    // Text inputs
    subtitleInput.addEventListener('input', () => { state.text.subtitle = subtitleInput.value; draw(); });
    titleInput.addEventListener('input', () => { state.text.title = titleInput.value; draw(); });
    textColor.addEventListener('input', () => { state.text.color = textColor.value; draw(); });
    textOffsetX.addEventListener('input', () => { state.text.offsetX = parseFloat(textOffsetX.value || 0); draw(); });
    textOffsetY.addEventListener('input', () => { state.text.offsetY = parseFloat(textOffsetY.value || 0); draw(); });

    // Circle inputs
    [circleX, circleY, circleR].forEach(inp => {
      inp.addEventListener('input', () => {
        state.circle.cx = parseFloat(circleX.value || 0);
        state.circle.cy = parseFloat(circleY.value || 0);
        state.circle.radius = parseFloat(circleR.value || state.circle.radius);
        circleSize.value = state.circle.radius;
        updateBadge(state.circle.cx, state.circle.cy, state.circle.radius);
        draw();
      });
    });
    circleSize.addEventListener('input', () => {
      state.circle.radius = parseInt(circleSize.value, 10);
      circleR.value = state.circle.radius;
      updateBadge(state.circle.cx, state.circle.cy, state.circle.radius);
      draw();
    });

    // Drag circle freely (even outside canvas)
    let dragging = false;
    let dragOffsetX = 0, dragOffsetY = 0;

    canvas.addEventListener('mousedown', (e) => {
      if (!state.img) return;
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (canvas.width / rect.width);
      const y = (e.clientY - rect.top) * (canvas.height / rect.height);
      const { x: cx, y: cy } = circleCenter();
      const r = state.circle.radius;
      const inside = Math.hypot(x - cx, y - cy) <= r;
      if (inside) {
        dragging = true;
        dragOffsetX = x - cx;
        dragOffsetY = y - cy;
        coordsBadge.classList.remove('hidden');
        positionBadge(e.clientX, e.clientY);
        updateBadge(cx, cy, r);
      }
    });

    window.addEventListener('mousemove', (e) => {
      if (!dragging) return;
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (canvas.width / rect.width);
      const y = (e.clientY - rect.top) * (canvas.height / rect.height);
      state.circle.cx = x - dragOffsetX;
      state.circle.cy = y - dragOffsetY;
      // sync inputs
      circleX.value = Math.round(state.circle.cx);
      circleY.value = Math.round(state.circle.cy);
      updateBadge(state.circle.cx, state.circle.cy, state.circle.radius);
      positionBadge(e.clientX, e.clientY);
      draw();
    });

    window.addEventListener('mouseup', () => {
      if (!dragging) return;
      dragging = false;
      setTimeout(()=>coordsBadge.classList.add('hidden'), 140);
    });

    function updateBadge(cx, cy, r){
      coordsBadge.textContent = `X: ${Math.round(cx)} ‚Ä¢ Y: ${Math.round(cy)} ‚Ä¢ R: ${Math.round(r)}`;
    }
    function positionBadge(clientX, clientY){
      const wrap = document.querySelector('.canvas-wrap');
      const rect = wrap.getBoundingClientRect();
      const x = Math.min(rect.right - 90, Math.max(rect.left + 6, clientX + 12));
      const y = Math.min(rect.bottom - 30, Math.max(rect.top + 6, clientY + 12));
      coordsBadge.style.left = x - rect.left + 'px';
      coordsBadge.style.top = y - rect.top + 'px';
    }

    // Download
    downloadBtn.addEventListener('click', () => {
      if (!state.img) {
        alert('Please upload an image first.');
        return;
      }
      canvas.toBlob((blob) => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'vertical-edit.png';
        document.body.appendChild(a);
        a.click();
        setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 100);
      }, 'image/png', 0.92);
    });
  </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'980f22050656d1c8',t:'MTc1ODE4MDU3My4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
