<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Instagram images for Compass Offices</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Font -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;600;800&display=swap" rel="stylesheet">
  <style>
    body{ font-family:'Inter',system-ui,Segoe UI,Roboto,Arial,sans-serif; background: radial-gradient(1100px 700px at 20% -10%, #121212 0%, #0a0a0a 60%, #000000 100%); }
    .glass{ background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03)); border:1px solid rgba(255,255,255,.08); backdrop-filter: blur(6px); }
    .canvas-wrap{ aspect-ratio: 9/16; position: relative; }
    input[type="file"]{ display:none; }
    .badge{ pointer-events:none; }
    .btn{ @apply px-3 py-2 rounded-lg border border-white/10 bg-white/5 hover:bg-white/10 transition; }
  </style>
  <link rel="icon" href="https://www.compassoffices.com/wp-content/themes/compass-offices/assets/images/compassoffices-logo-web-all-in-one-2025_icon-o.svg" type="image/svg+xml">
</head>
<body class="text-slate-100 min-h-screen">
  <!-- Header -->
  <header class="w-full max-w-6xl mx-auto px-4 sm:px-6 py-5 flex items-center justify-between">
    <div class="flex items-center gap-3">
      <div class="w-10 h-10 rounded-xl bg-[#ff6600] grid place-items-center shadow-lg shadow-black/40">
        <img src="https://www.compassoffices.com/wp-content/themes/compass-offices/assets/images/compassoffices-logo-web-all-in-one-2025_icon-o.svg" alt="Compass Offices icon" class="w-7 h-7" onerror="this.src=''; this.alt='Image failed to load'; this.style.display='none';"/>
      </div>
      <div>
        <h1 class="text-xl sm:text-2xl font-extrabold tracking-tight">Instagram images for Compass Offices - Image Editor</h1>
        <p class="text-slate-300 text-xs sm:text-sm">Upload â€¢ move/zoom image â€¢ glassy blurred circle â€¢ live X/Y/R â€¢ large text inside</p>
      </div>
    </div>
    <div class="flex items-center gap-2">
      <button id="downloadBtn" class="px-4 py-2 rounded-lg bg-[#ff6600] hover:bg-[#ff7f2a] text-black font-semibold shadow-lg transition">Download</button>
    </div>
  </header>

  <!-- Main -->
  <main class="w-full max-w-6xl mx-auto px-4 sm:px-6 pb-10">
    <div class="grid grid-cols-1 lg:grid-cols-[380px_minmax(0,1fr)] gap-6">
      <!-- Controls -->
      <section class="glass rounded-2xl p-5 space-y-6 border border-[#ff6600]/30">
        <!-- Start + Image Adjust -->
        <div class="space-y-4">
          <h2 class="font-semibold text-lg text-[#ff6600]">Start</h2>
          <label class="block">
            <input id="fileInput" type="file" accept="image/*" />
            <div class="w-full cursor-pointer rounded-xl border border-white/10 bg-white/5 hover:bg-white/10 transition p-4 flex items-center justify-between">
              <div class="flex items-center gap-3">
                <div class="w-9 h-9 rounded-lg bg-[#ff6600] grid place-items-center text-black">ðŸ“¤</div>
                <div>
                  <p class="font-semibold">Upload image</p>
                  <p class="text-xs text-slate-300">PNG â€¢ JPG â€¢ WEBP</p>
                </div>
              </div>
              <span class="text-sm px-3 py-1 rounded-lg bg-white/10">Choose</span>
            </div>
          </label>

          <div class="space-y-2">
            <div class="flex items-center justify-between">
              <h3 class="text-sm font-semibold text-slate-200">Image adjust</h3>
              <button id="resetImageBtn" class="text-xs btn">Reset</button>
            </div>
            <div class="grid grid-cols-3 gap-2">
              <div class="space-y-1">
                <label class="text-xs text-slate-400" style="color:#bbb;" for="imgX">Image X</label>
                <input id="imgX" type="number" value="0" class="w-full rounded-lg bg-white/5 border border-white/10 px-2 py-2 outline-none">
              </div>
              <div class="space-y-1">
                <label class="text-xs text-slate-400" style="color:#bbb;" for="imgY">Image Y</label>
                <input id="imgY" type="number" value="0" class="w-full rounded-lg bg-white/5 border border-white/10 px-2 py-2 outline-none">
              </div>
              <div class="space-y-1">
                <label class="text-xs text-slate-400" style="color:#bbb;" for="imgScaleNumber">Scale</label>
                <input id="imgScaleNumber" type="number" step="0.01" value="1" class="w-full rounded-lg bg-white/5 border border-white/10 px-2 py-2 outline-none">
              </div>
            </div>
            <div class="flex items-center gap-2">
              <button id="zoomOutBtn" class="btn">âˆ’</button>
              <input id="imgScaleRange" type="range" min="0.5" max="3" step="0.01" value="1" class="flex-1">
              <button id="zoomInBtn" class="btn">+</button>
            </div>
            <p class="text-xs text-slate-400" style="color:#bbb;">Tip: Use X/Y to pan and the slider or âˆ’/+ to zoom the background photo.</p>
          </div>
        </div>

        <div class="h-px bg-white/10"></div>

        <!-- Text -->
        <div class="space-y-3">
          <h2 class="font-semibold text-lg text-[#ff6600]">Text inside circle</h2>
          <input id="subtitleInput" type="text" placeholder="Subtitle (thin)" class="w-full rounded-lg bg-white/5 border border-white/10 px-3 py-2 outline-none focus:ring-2 focus:ring-[#ff6600]/40" />
          <input id="titleInput" type="text" placeholder="Title (bold)" class="w-full rounded-lg bg-white/5 border border-white/10 px-3 py-2 outline-none focus:ring-2 focus:ring-[#ff6600]/40" />
          <div class="grid grid-cols-3 gap-2">
            <div class="space-y-1">
              <label class="text-xs text-slate-400" style="color:#bbb;" for="textOffsetX">Text offset X</label>
              <input id="textOffsetX" type="number" value="100" class="w-full rounded-lg bg-white/5 border border-white/10 px-2 py-2 outline-none">
            </div>
            <div class="space-y-1">
              <label class="text-xs text-slate-400" style="color:#bbb;" for="textOffsetY">Text offset Y</label>
              <input id="textOffsetY" type="number" value="-150" class="w-full rounded-lg bg-white/5 border border-white/10 px-2 py-2 outline-none">
            </div>
            <div class="space-y-1">
              <label class="text-xs text-slate-400" style="color:#bbb;" for="textColor">Color</label>
              <input id="textColor" type="color" value="#ffffff" class="w-full h-[42px] rounded-lg border border-white/10 bg-transparent">
            </div>
          </div>
          <p class="text-xs text-slate-400" style="color:#bbb;">Fixed sizes: subtitle 54 (thin), title 80 (bold). Leftâ€‘aligned, block centered vertically (nudged up).</p>
        </div>

        <div class="h-px bg-white/10"></div>

        <!-- Circle -->
        <div class="space-y-3">
          <h2 class="font-semibold text-lg text-[#ff6600]">Circle</h2>
          <div class="grid grid-cols-3 gap-2">
            <div class="space-y-1">
              <label class="text-xs text-slate-400" style="color:#bbb;" for="circleX">X</label>
              <input id="circleX" type="number" value="480" class="w-full rounded-lg bg-white/5 border border-white/10 px-2 py-2 outline-none">
            </div>
            <div class="space-y-1">
              <label class="text-xs text-slate-400" style="color:#bbb;" for="circleY">Y</label>
              <input id="circleY" type="number" value="1600" class="w-full rounded-lg bg-white/5 border border-white/10 px-2 py-2 outline-none">
            </div>
            <div class="space-y-1">
              <label class="text-xs text-slate-400" style="color:#bbb;" for="circleR">R</label>
              <input id="circleR" type="number" value="525" class="w-full rounded-lg bg-white/5 border border-white/10 px-2 py-2 outline-none">
            </div>
          </div>
          <div class="flex items-center justify-between gap-2">
            <label for="circleSize" class="text-sm text-slate-300">Radius (R)</label>
            <input id="circleSize" type="range" min="160" max="560" value="525" class="w-40">
          </div>
          <p class="text-xs text-slate-400" style="color:#bbb;">Drag the circle to move it. A badge shows X/Y/R while dragging.</p>
        </div>
      </section>

      <!-- Canvas -->
      <section class="glass rounded-2xl p-4 border border-[#ff6600]/30">
        <div class="flex items-center justify-between px-1 py-1">
          <div class="text-sm text-slate-300">Canvas 1080Ã—1920</div>
          <div class="text-xs text-slate-400" style="color:#bbb;">Vertical â€¢ Glassy circle</div>
        </div>
        <div class="canvas-wrap w-full rounded-xl overflow-hidden bg-[#0d1222] grid place-items-center">
          <canvas id="canvas" width="1080" height="1920" class="w-full h-auto"></canvas>
          <div id="coordsBadge" class="badge absolute text-[11px] leading-none px-2 py-1 rounded-md bg-black/70 border border-white/10 shadow-md hidden">X: 0 â€¢ Y: 0 â€¢ R: 0</div>
          <div id="emptyState" class="absolute text-center text-slate-300 opacity-80 px-6">
            <div class="mb-3">
              <img src="https://www.compassoffices.com/wp-content/themes/compass-offices/assets/images/compassoffices-logo-web-all-in-one-2025_icon-w.svg" alt="Compass icon white" class="w-14 h-14 mx-auto" onerror="this.src=''; this.alt='Image failed to load'; this.style.display='none';"/>
            </div>
            <p class="text-lg font-semibold">Upload an image to begin</p>
            <p class="text-sm">Move/zoom the image; drag the glassy blurred circle; type your text.</p>
          </div>
        </div>
      </section>
    </div>
  </main>

  <script>
    // State
    const state = {
      img: null,
      imgW: 0, imgH: 0,
      cover: { dx:0, dy:0, dw:0, dh:0 },
      imageAdjust: { x: 0, y: 0, scale: 1 },
      circle: { mode:'free', cx: 480, cy: 1600, radius: 525 },
      text: {
        subtitle:'', title:'',
        color:'#ffffff',
        subtitleSize:54,
        titleSize:80,
        offsetX: 100,
        offsetY: -150
      }
    };

    // Elements
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const fileInput = document.getElementById('fileInput');

    const subtitleInput = document.getElementById('subtitleInput');
    const titleInput = document.getElementById('titleInput');
    const textColor = document.getElementById('textColor');
    const textOffsetX = document.getElementById('textOffsetX');
    const textOffsetY = document.getElementById('textOffsetY');

    const circleX = document.getElementById('circleX');
    const circleY = document.getElementById('circleY');
    const circleR = document.getElementById('circleR');
    const circleSize = document.getElementById('circleSize');

    const coordsBadge = document.getElementById('coordsBadge');
    const emptyState = document.getElementById('emptyState');
    const downloadBtn = document.getElementById('downloadBtn');

    const imgX = document.getElementById('imgX');
    const imgY = document.getElementById('imgY');
    const imgScaleNumber = document.getElementById('imgScaleNumber');
    const imgScaleRange = document.getElementById('imgScaleRange');
    const resetImageBtn = document.getElementById('resetImageBtn');
    const zoomInBtn = document.getElementById('zoomInBtn');
    const zoomOutBtn = document.getElementById('zoomOutBtn');

    // Grain helper
    let noisePattern = null;
    function ensureNoisePattern(ctx){
      if (noisePattern) return noisePattern;
      const n = document.createElement('canvas');
      const s = 128; n.width = s; n.height = s;
      const nctx = n.getContext('2d');
      const imgData = nctx.createImageData(s, s);
      for (let i=0;i<imgData.data.length;i+=4){
        const v = Math.random()*255;
        imgData.data[i] = v;
        imgData.data[i+1] = v;
        imgData.data[i+2] = v;
        imgData.data[i+3] = 255;
      }
      nctx.putImageData(imgData,0,0);
      noisePattern = ctx.createPattern(n, 'repeat');
      return noisePattern;
    }

    // Helpers
    function computeCover() {
      if (!state.img) return;
      const cw = canvas.width, ch = canvas.height;
      const s = Math.max(cw / state.imgW, ch / state.imgH);
      const dw = state.imgW * s, dh = state.imgH * s;
      const dx = (cw - dw) / 2, dy = (ch - dh) / 2;
      state.cover = { dx, dy, dw, dh };
    }

    function circleCenter() {
      return { x: state.circle.cx, y: state.circle.cy };
    }

    function drawBackground() {
      const { dx, dy, dw, dh } = state.cover;
      const { x: ox, y: oy, scale } = state.imageAdjust;
      const sw = dw * scale, sh = dh * scale;
      const cx = dx + ox + (dw - sw)/2;
      const cy = dy + oy + (dh - sh)/2;
      ctx.drawImage(state.img, cx, cy, sw, sh);
    }

    // Glassy circle: extra blur + subtle dark edge + grain
    function drawGlassyCircle() {
      const { x, y } = circleCenter();
      const r = state.circle.radius;

      ctx.save();
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.clip();

      // sample bg with strong blur
      const { dx, dy, dw, dh } = state.cover;
      ctx.filter = 'blur(14px)';
      ctx.drawImage(state.img, dx, dy, dw, dh);
      ctx.filter = 'none';

      // subtle edge darkening
      const depth = ctx.createRadialGradient(x, y, r * 0.35, x, y, r);
      depth.addColorStop(0, 'rgba(0,0,0,0)');
      depth.addColorStop(1, 'rgba(0,0,0,0.28)');
      ctx.fillStyle = depth;
      ctx.fillRect(x - r, y - r, r * 2, r * 2);

      // thin frost
      ctx.fillStyle = 'rgba(255,255,255,0.05)';
      ctx.fillRect(x - r, y - r, r * 2, r * 2);

      // gentle gloss
      const hl = ctx.createRadialGradient(x - r * 0.35, y - r * 0.35, 0, x - r * 0.35, y - r * 0.35, r * 0.9);
      hl.addColorStop(0, 'rgba(255,255,255,0.14)');
      hl.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = hl;
      ctx.fillRect(x - r, y - r, r * 2, r * 2);

      // light grain
      ctx.globalCompositeOperation = 'multiply';
      ctx.globalAlpha = 0.06;
      ctx.fillStyle = ensureNoisePattern(ctx);
      ctx.fillRect(x - r, y - r, r * 2, r * 2);
      ctx.globalAlpha = 1;
      ctx.globalCompositeOperation = 'source-over';

      ctx.restore();
    }

    // Text inside the circle
    function drawTextInCircle() {
      const { subtitle, title, color, subtitleSize, titleSize, offsetX, offsetY } = state.text;
      if (!subtitle && !title) return;

      const { x, y } = circleCenter();
      const r = state.circle.radius;
      const padding = 28;
      const leftX = (x - r + padding) + offsetX;
      const maxW = (r * 2) - padding * 2;

      ctx.save();
      ctx.fillStyle = color;
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';

      // measure
      ctx.font = `300 ${subtitleSize}px Inter`;
      const subLines = subtitle ? wrapLines(ctx, subtitle, maxW) : [];
      const subH = subLines.length * (subtitleSize * 1.28);
      const gap = (subtitle && title) ? 10 : 0;

      ctx.font = `800 ${titleSize}px Inter`;
      const titleLines = title ? wrapLines(ctx, title, maxW) : [];
      const titleH = titleLines.length * (titleSize * 1.12);
      const totalH = subH + gap + titleH;

      // clip
      ctx.beginPath();
      ctx.arc(x, y, r - 8, 0, Math.PI * 2);
      ctx.clip();

      // soft shadow for readability
      ctx.shadowColor = 'rgba(0,0,0,0.35)';
      ctx.shadowBlur = 16;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 8;

      // render centered + offsets
      let cy = y - totalH / 2 + offsetY;

      if (subLines.length) {
        ctx.font = `300 ${subtitleSize}px Inter`;
        for (const line of subLines) {
          ctx.fillText(line, leftX, cy);
          cy += subtitleSize * 1.28;
        }
        cy += gap;
      }

      if (titleLines.length) {
        ctx.font = `800 ${titleSize}px Inter`;
        for (const line of titleLines) {
          ctx.fillText(line, leftX, cy);
          cy += titleSize * 1.12;
        }
      }

      ctx.restore();
    }

    function wrapLines(context, text, maxWidth) {
      const words = (text || '').split(/\s+/);
      const lines = [];
      let line = '';
      for (let i = 0; i < words.length; i++) {
        const test = line ? line + ' ' + words[i] : words[i];
        if (context.measureText(test).width > maxWidth && line) {
          lines.push(line);
          line = words[i];
        } else {
          line = test;
        }
      }
      if (line) lines.push(line);
      return lines;
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (!state.img) return;
      drawBackground();
      drawGlassyCircle();
      drawTextInCircle();
    }

    // Load image
    fileInput.addEventListener('change', (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        const img = new Image();
        img.onload = () => {
          state.img = img;
          state.imgW = img.naturalWidth;
          state.imgH = img.naturalHeight;
          computeCover();
          emptyState.style.display = 'none';
          syncImageControls();
          syncCircleControls();
          syncTextControls();
          draw();
        };
        img.src = reader.result;
      };
      reader.readAsDataURL(file);
    });

    window.addEventListener('resize', () => {
      if (state.img) { computeCover(); draw(); }
    });

    // Image controls
    function clampScale(v){ return Math.min(3, Math.max(0.5, v)); }
    function syncImageControls(){
      imgX.value = state.imageAdjust.x;
      imgY.value = state.imageAdjust.y;
      imgScaleNumber.value = state.imageAdjust.scale.toFixed(2);
      imgScaleRange.value = state.imageAdjust.scale.toFixed(2);
    }
    function setScale(newScale){
      state.imageAdjust.scale = clampScale(newScale);
      syncImageControls();
      draw();
    }
    imgX.addEventListener('input', ()=>{ state.imageAdjust.x = parseFloat(imgX.value || 0); draw(); });
    imgY.addEventListener('input', ()=>{ state.imageAdjust.y = parseFloat(imgY.value || 0); draw(); });
    imgScaleNumber.addEventListener('input', ()=>{
      let s = parseFloat(imgScaleNumber.value || 1);
      if (!isFinite(s)) s = 1;
      setScale(s);
    });
    imgScaleRange.addEventListener('input', ()=>{
      let s = parseFloat(imgScaleRange.value || 1);
      if (!isFinite(s)) s = 1;
      setScale(s);
    });
    zoomInBtn.addEventListener('click', (e)=>{ e.preventDefault(); setScale(state.imageAdjust.scale + 0.05); });
    zoomOutBtn.addEventListener('click', (e)=>{ e.preventDefault(); setScale(state.imageAdjust.scale - 0.05); });
    resetImageBtn.addEventListener('click', (e)=>{
      e.preventDefault();
      state.imageAdjust = { x:0, y:0, scale:1 };
      syncImageControls();
      draw();
    });

    // Text inputs
    function syncTextControls(){
      textColor.value = state.text.color;
      textOffsetX.value = state.text.offsetX;
      textOffsetY.value = state.text.offsetY;
    }
    subtitleInput.addEventListener('input', () => { state.text.subtitle = subtitleInput.value; draw(); });
    titleInput.addEventListener('input', () => { state.text.title = titleInput.value; draw(); });
    textColor.addEventListener('input', () => { state.text.color = textColor.value; draw(); });
    textOffsetX.addEventListener('input', () => { state.text.offsetX = parseFloat(textOffsetX.value || 0); draw(); });
    textOffsetY.addEventListener('input', () => { state.text.offsetY = parseFloat(textOffsetY.value || 0); draw(); });

    // Circle inputs
    function syncCircleControls(){
      circleX.value = Math.round(state.circle.cx);
      circleY.value = Math.round(state.circle.cy);
      circleR.value = Math.round(state.circle.radius);
      circleSize.value = state.circle.radius;
    }
    ;[circleX, circleY, circleR].forEach(inp => {
      inp.addEventListener('input', () => {
        state.circle.cx = parseFloat(circleX.value || 0);
        state.circle.cy = parseFloat(circleY.value || 0);
        state.circle.radius = parseFloat(circleR.value || state.circle.radius);
        circleSize.value = state.circle.radius;
        updateBadge(state.circle.cx, state.circle.cy, state.circle.radius);
        draw();
      });
    });
    circleSize.addEventListener('input', () => {
      state.circle.radius = parseInt(circleSize.value, 10);
      circleR.value = state.circle.radius;
      updateBadge(state.circle.cx, state.circle.cy, state.circle.radius);
      draw();
    });

    // Drag circle freely
    let dragging = false;
    let dragOffsetX = 0, dragOffsetY = 0;

    canvas.addEventListener('mousedown', (e) => {
      if (!state.img) return;
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (canvas.width / rect.width);
      const y = (e.clientY - rect.top) * (canvas.height / rect.height);
      const { x: cx, y: cy } = circleCenter();
      const r = state.circle.radius;
      const inside = Math.hypot(x - cx, y - cy) <= r;
      if (inside) {
        dragging = true;
        dragOffsetX = x - cx;
        dragOffsetY = y - cy;
        coordsBadge.classList.remove('hidden');
        positionBadge(e.clientX, e.clientY);
        updateBadge(cx, cy, r);
      }
    });

    window.addEventListener('mousemove', (e) => {
      if (!dragging) return;
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (canvas.width / rect.width);
      const y = (e.clientY - rect.top) * (canvas.height / rect.height);
      state.circle.cx = x - dragOffsetX;
      state.circle.cy = y - dragOffsetY;
      syncCircleControls();
      updateBadge(state.circle.cx, state.circle.cy, state.circle.radius);
      positionBadge(e.clientX, e.clientY);
      draw();
    });

    window.addEventListener('mouseup', () => {
      if (!dragging) return;
      dragging = false;
      setTimeout(()=>coordsBadge.classList.add('hidden'), 140);
    });

    function updateBadge(cx, cy, r){
      coordsBadge.textContent = `X: ${Math.round(cx)} â€¢ Y: ${Math.round(cy)} â€¢ R: ${Math.round(r)}`;
    }
    function positionBadge(clientX, clientY){
      const wrap = document.querySelector('.canvas-wrap');
      const rect = wrap.getBoundingClientRect();
      const x = Math.min(rect.right - 90, Math.max(rect.left + 6, clientX + 12));
      const y = Math.min(rect.bottom - 30, Math.max(rect.top + 6, clientY + 12));
      coordsBadge.style.left = x - rect.left + 'px';
      coordsBadge.style.top = y - rect.top + 'px';
    }

    // Download
    downloadBtn.addEventListener('click', () => {
      if (!state.img) {
        alert('Please upload an image first.');
        return;
      }
      canvas.toBlob((blob) => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'vertical-edit.png';
        document.body.appendChild(a);
        a.click();
        setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 100);
      }, 'image/png', 0.92);
    });
  </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9815a5c373f3fcb2',t:'MTc1ODI0ODg4NC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
